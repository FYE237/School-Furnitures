{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { snapValueToStep as $drHW0$snapValueToStep, clamp as $drHW0$clamp } from \"@react-aria/utils\";\nimport { useControlledState as $drHW0$useControlledState } from \"@react-stately/utils\";\nimport { useState as $drHW0$useState, useRef as $drHW0$useRef } from \"react\";\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nvar $8f011f344c0ccbcc$exports = {};\n$parcel$export($8f011f344c0ccbcc$exports, \"useSliderState\", function () {\n  return $8f011f344c0ccbcc$export$e5fda3247f5d67f9;\n});\nvar $8f011f344c0ccbcc$var$DEFAULT_MIN_VALUE = 0;\nvar $8f011f344c0ccbcc$var$DEFAULT_MAX_VALUE = 100;\nvar $8f011f344c0ccbcc$var$DEFAULT_STEP_VALUE = 1;\n\nfunction $8f011f344c0ccbcc$export$e5fda3247f5d67f9(props) {\n  var isDisabled = props.isDisabled,\n      _props$minValue = props.minValue,\n      minValue = _props$minValue === void 0 ? $8f011f344c0ccbcc$var$DEFAULT_MIN_VALUE : _props$minValue,\n      _props$maxValue = props.maxValue,\n      maxValue = _props$maxValue === void 0 ? $8f011f344c0ccbcc$var$DEFAULT_MAX_VALUE : _props$maxValue,\n      formatter = props.numberFormatter,\n      _props$step = props.step,\n      step = _props$step === void 0 ? $8f011f344c0ccbcc$var$DEFAULT_STEP_VALUE : _props$step;\n\n  var _defaultValue;\n\n  var _$drHW0$useControlled = $drHW0$useControlledState(props.value, (_defaultValue = props.defaultValue) !== null && _defaultValue !== void 0 ? _defaultValue : [minValue], props.onChange),\n      _$drHW0$useControlled2 = _slicedToArray(_$drHW0$useControlled, 2),\n      values = _$drHW0$useControlled2[0],\n      setValues = _$drHW0$useControlled2[1];\n\n  var _$drHW0$useState = $drHW0$useState(new Array(values.length).fill(false)),\n      _$drHW0$useState2 = _slicedToArray(_$drHW0$useState, 2),\n      isDraggings = _$drHW0$useState2[0],\n      setDraggings = _$drHW0$useState2[1];\n\n  var isEditablesRef = $drHW0$useRef(new Array(values.length).fill(true));\n\n  var _$drHW0$useState3 = $drHW0$useState(undefined),\n      _$drHW0$useState4 = _slicedToArray(_$drHW0$useState3, 2),\n      focusedIndex = _$drHW0$useState4[0],\n      setFocusedIndex = _$drHW0$useState4[1];\n\n  var valuesRef = $drHW0$useRef(null);\n  valuesRef.current = values;\n  var isDraggingsRef = $drHW0$useRef(null);\n  isDraggingsRef.current = isDraggings;\n\n  function getValuePercent(value) {\n    return (value - minValue) / (maxValue - minValue);\n  }\n\n  function getThumbMinValue(index) {\n    return index === 0 ? minValue : values[index - 1];\n  }\n\n  function getThumbMaxValue(index) {\n    return index === values.length - 1 ? maxValue : values[index + 1];\n  }\n\n  function isThumbEditable(index) {\n    return isEditablesRef.current[index];\n  }\n\n  function setThumbEditable(index, editable) {\n    isEditablesRef.current[index] = editable;\n  }\n\n  function updateValue(index, value) {\n    if (isDisabled || !isThumbEditable(index)) return;\n    var thisMin = getThumbMinValue(index);\n    var thisMax = getThumbMaxValue(index);\n    value = $drHW0$snapValueToStep(value, thisMin, thisMax, step);\n    valuesRef.current = $8f011f344c0ccbcc$var$replaceIndex(valuesRef.current, index, value);\n    setValues(valuesRef.current);\n  }\n\n  function updateDragging(index, dragging) {\n    if (isDisabled || !isThumbEditable(index)) return;\n    var wasDragging = isDraggingsRef.current[index];\n    isDraggingsRef.current = $8f011f344c0ccbcc$var$replaceIndex(isDraggingsRef.current, index, dragging);\n    setDraggings(isDraggingsRef.current);\n    if (props.onChangeEnd && wasDragging && !isDraggingsRef.current.some(Boolean)) props.onChangeEnd(valuesRef.current);\n  }\n\n  function getFormattedValue(value) {\n    return formatter.format(value);\n  }\n\n  function setThumbPercent(index, percent) {\n    updateValue(index, getPercentValue(percent));\n  }\n\n  function getRoundedValue(value) {\n    return Math.round((value - minValue) / step) * step + minValue;\n  }\n\n  function getPercentValue(percent) {\n    var val = percent * (maxValue - minValue) + minValue;\n    return $drHW0$clamp(getRoundedValue(val), minValue, maxValue);\n  }\n\n  return {\n    values: values,\n    getThumbValue: function getThumbValue(index) {\n      return values[index];\n    },\n    setThumbValue: updateValue,\n    setThumbPercent: setThumbPercent,\n    isThumbDragging: function isThumbDragging(index) {\n      return isDraggings[index];\n    },\n    setThumbDragging: updateDragging,\n    focusedThumb: focusedIndex,\n    setFocusedThumb: setFocusedIndex,\n    getThumbPercent: function getThumbPercent(index) {\n      return getValuePercent(values[index]);\n    },\n    getValuePercent: getValuePercent,\n    getThumbValueLabel: function getThumbValueLabel(index) {\n      return getFormattedValue(values[index]);\n    },\n    getFormattedValue: getFormattedValue,\n    getThumbMinValue: getThumbMinValue,\n    getThumbMaxValue: getThumbMaxValue,\n    getPercentValue: getPercentValue,\n    isThumbEditable: isThumbEditable,\n    setThumbEditable: setThumbEditable,\n    step: step\n  };\n}\n\nfunction $8f011f344c0ccbcc$var$replaceIndex(array, index, value) {\n  if (array[index] === value) return array;\n  return [].concat(_toConsumableArray(array.slice(0, index)), [value], _toConsumableArray(array.slice(index + 1)));\n}\n\nexport { $8f011f344c0ccbcc$export$e5fda3247f5d67f9 as useSliderState };","map":{"version":3,"sources":["packages/@react-stately/slider/src/useSliderState.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {clamp, snapValueToStep} from '@react-aria/utils';\nimport {SliderProps} from '@react-types/slider';\nimport {useControlledState} from '@react-stately/utils';\nimport {useRef, useState} from 'react';\n\nexport interface SliderState {\n  /**\n   * Values managed by the slider by thumb index.\n   */\n  readonly values: number[],\n  /**\n   * Get the value for the specified thumb.\n   * @param index\n   */\n  getThumbValue(index: number): number,\n\n  /**\n   * Sets the value for the specified thumb.\n   * The actual value set will be clamped and rounded according to min/max/step.\n   * @param index\n   * @param value\n   */\n  setThumbValue(index: number, value: number): void,\n\n  /**\n   * Sets value for the specified thumb by percent offset (between 0 and 1).\n   * @param index\n   * @param percent\n   */\n  setThumbPercent(index: number, percent: number): void,\n\n  /**\n   * Whether the specific thumb is being dragged.\n   * @param index\n   */\n  isThumbDragging(index: number): boolean,\n  /**\n   * Set is dragging on the specified thumb.\n   * @param index\n   * @param dragging\n   */\n  setThumbDragging(index: number, dragging: boolean): void,\n\n  /**\n   * Currently-focused thumb index.\n   */\n  readonly focusedThumb: number | undefined,\n  /**\n   * Set focused true on specified thumb. This will remove focus from\n   * any thumb that had it before.\n   * @param index\n   */\n  setFocusedThumb(index: number | undefined): void,\n\n  /**\n   * Returns the specified thumb's value as a percentage from 0 to 1.\n   * @param index\n   */\n  getThumbPercent(index: number): number,\n\n  /**\n   * Returns the value as a percent between the min and max of the slider.\n   * @param index\n   */\n  getValuePercent(value: number): number,\n\n  /**\n   * Returns the string label for the specified thumb's value, per props.formatOptions.\n   * @param index\n   */\n  getThumbValueLabel(index: number): string,\n\n  /**\n   * Returns the string label for the value, per props.formatOptions.\n   * @param index\n   */\n  getFormattedValue(value: number): string,\n\n  /**\n   * Returns the min allowed value for the specified thumb.\n   * @param index\n   */\n  getThumbMinValue(index: number): number,\n\n  /**\n   * Returns the max allowed value for the specified thumb.\n   * @param index\n   */\n  getThumbMaxValue(index: number): number,\n\n  /**\n   * Converts a percent along track (between 0 and 1) to the corresponding value.\n   * @param percent\n   */\n  getPercentValue(percent: number): number,\n\n  /**\n   * Returns if the specified thumb is editable.\n   * @param index\n   */\n  isThumbEditable(index: number): boolean,\n\n  /**\n   * Set the specified thumb's editable state.\n   * @param index\n   * @param editable\n   */\n  setThumbEditable(index: number, editable: boolean): void,\n\n  /**\n   * The step amount for the slider.\n   */\n  readonly step: number\n}\n\nconst DEFAULT_MIN_VALUE = 0;\nconst DEFAULT_MAX_VALUE = 100;\nconst DEFAULT_STEP_VALUE = 1;\n\ninterface SliderStateOptions extends SliderProps {\n  numberFormatter: Intl.NumberFormat\n}\n\n/**\n * Provides state management for a slider component. Stores values for all thumbs,\n * formats values for localization, and provides methods to update the position\n * of any thumbs.\n * @param props\n */\nexport function useSliderState(props: SliderStateOptions): SliderState {\n  const {isDisabled, minValue = DEFAULT_MIN_VALUE, maxValue = DEFAULT_MAX_VALUE, numberFormatter: formatter, step = DEFAULT_STEP_VALUE} = props;\n\n  const [values, setValues] = useControlledState<number[]>(\n    props.value as any,\n    props.defaultValue ?? [minValue] as any,\n    props.onChange as any\n  );\n  const [isDraggings, setDraggings] = useState<boolean[]>(new Array(values.length).fill(false));\n  const isEditablesRef = useRef<boolean[]>(new Array(values.length).fill(true));\n  const [focusedIndex, setFocusedIndex] = useState<number | undefined>(undefined);\n\n  const valuesRef = useRef<number[]>(null);\n  valuesRef.current = values;\n  const isDraggingsRef = useRef<boolean[]>(null);\n  isDraggingsRef.current = isDraggings;\n\n  function getValuePercent(value: number) {\n    return (value - minValue) / (maxValue - minValue);\n  }\n\n  function getThumbMinValue(index: number) {\n    return index === 0 ? minValue : values[index - 1];\n  }\n  function getThumbMaxValue(index: number) {\n    return index === values.length - 1 ? maxValue : values[index + 1];\n  }\n\n  function isThumbEditable(index: number) {\n    return isEditablesRef.current[index];\n  }\n\n  function setThumbEditable(index: number, editable: boolean) {\n    isEditablesRef.current[index] = editable;\n  }\n\n  function updateValue(index: number, value: number) {\n    if (isDisabled || !isThumbEditable(index)) {\n      return;\n    }\n    const thisMin = getThumbMinValue(index);\n    const thisMax = getThumbMaxValue(index);\n\n    // Round value to multiple of step, clamp value between min and max\n    value = snapValueToStep(value, thisMin, thisMax, step);\n    valuesRef.current = replaceIndex(valuesRef.current, index, value);\n    setValues(valuesRef.current);\n  }\n\n  function updateDragging(index: number, dragging: boolean) {\n    if (isDisabled || !isThumbEditable(index)) {\n      return;\n    }\n\n    const wasDragging = isDraggingsRef.current[index];\n    isDraggingsRef.current = replaceIndex(isDraggingsRef.current, index, dragging);\n    setDraggings(isDraggingsRef.current);\n\n    // Call onChangeEnd if no handles are dragging.\n    if (props.onChangeEnd && wasDragging && !isDraggingsRef.current.some(Boolean)) {\n      props.onChangeEnd(valuesRef.current);\n    }\n  }\n\n  function getFormattedValue(value: number) {\n    return formatter.format(value);\n  }\n\n  function setThumbPercent(index: number, percent: number) {\n    updateValue(index, getPercentValue(percent));\n  }\n\n  function getRoundedValue(value: number) {\n    return Math.round((value - minValue) / step) * step + minValue;\n  }\n\n  function getPercentValue(percent: number) {\n    const val = percent * (maxValue - minValue) + minValue;\n    return clamp(getRoundedValue(val), minValue, maxValue);\n  }\n\n  return {\n    values: values,\n    getThumbValue: (index: number) => values[index],\n    setThumbValue: updateValue,\n    setThumbPercent,\n    isThumbDragging: (index: number) => isDraggings[index],\n    setThumbDragging: updateDragging,\n    focusedThumb: focusedIndex,\n    setFocusedThumb: setFocusedIndex,\n    getThumbPercent: (index: number) => getValuePercent(values[index]),\n    getValuePercent,\n    getThumbValueLabel: (index: number) => getFormattedValue(values[index]),\n    getFormattedValue,\n    getThumbMinValue,\n    getThumbMaxValue,\n    getPercentValue,\n    isThumbEditable,\n    setThumbEditable,\n    step\n  };\n}\n\nfunction replaceIndex<T>(array: T[], index: number, value: T) {\n  if (array[index] === value) {\n    return array;\n  }\n\n  return [...array.slice(0, index), value, ...array.slice(index + 1)];\n}\n"]},"metadata":{},"sourceType":"module"}